# Challenge 4 (hardest crypto chall ive ever solved) :

## Flag : 
`MCTF{hardy_muskat_williams2coppersmith}`


# Resources Used :

- https://github.com/mimoo/RSA-and-LLL-attacks : `to understand coppersmith and LLL on univariate and bivariate equations`

- https://en.wikipedia.org/wiki/General_number_field_sieve : `tangent i went on gnfs is too slow for this but itll work with enough time and compute`
- https://mathoverflow.net/questions/199432/factorization-when-a-factor-is-partially-known : `to understand % high bits needed for coppersmith attack`
- https://github.com/RsaCtfTool/RsaCtfTool/tree/master?tab=readme-ov-file : (good tool for known attacks) `wasnt used in this chall`
- https://latticehacks.cr.yp.to/rsa.html : `to understand LLL but LLL doesnt work well in this chall`
- I used a lot more resources but these are the main ones.


## Solve : 

first lets look at the challenge code : 
```py
from sage.all import randint, next_prime
from Crypto.Util.number import bytes_to_long

class RSA:
    def __init__(self, hb, lb) -> None:
        self.hb = hb
        self.lb = lb
        self.u1 = randint(0, 2**30)
        self.u2 = randint(0, 2**30)
        self.keygen()
    
    def keygen(self) -> None:
        self.base = randint(2**self.hb-1, 2**self.hb)
        self.e = 0x10001
        self.p = next_prime(self.u1*self.base + randint(2, 2**self.lb))
        self.q = next_prime(self.u2*self.base + randint(2, 2**self.lb))
        self.n = self.p * self.q

    def sum(self):
        return self.u1**2 + self.u2**2

    def encrypt(self, m: bytes) -> int:
        m_ = bytes_to_long(m)
        c = pow(m_, self.e, self.n)
        return c
    

rsa = RSA(
    hb=2048,
    lb=256
)
print(f"c0 = {rsa.sum()}")
print(f"c1 = {rsa.encrypt(b'REDACTED FLAG')}")
print(f"c2 = {rsa.encrypt(b'Lorem Ipsum is simply dummy text of')}")
print(f"c3 = {rsa.encrypt(b'the printing and typesetting industry')}")
```

- Ill try to explain the script as best as possible : 

- we are encrypting 3 messages 2 of which are known to us into 3 rsa cipher texts.
- how rsa works to the best of my knowledge is like like this = 
- first we convert our text to long int values and then we have defined e = 65537
- then we define N = p * q which is our public Key.
- we will talk about p and q later.
- since we know `m_` : our known plaintext in long int form and e value and ciphertext. we can solve an equation to get our N value easily.


```py
from sage.all import *
from Crypto.Util.number import long_to_bytes, bytes_to_long


c0 = ...
c1 = ...
c2 = ..
c3 = ...
e = 0x10001

# Known plaintexts
m2 = bytes_to_long(b'Lorem Ipsum is simply dummy text of')
m3 = bytes_to_long(b'the printing and typesetting industry')


# Franklin-Reiter: compute gcd to recover N
g1 = pow(m2, e) - c2
g2 = pow(m3, e) - c3
N = gcd(g1, g2)
print(f"Recovered N: {N}")
print(f"N bit length: {N.nbits()}")

```

```
Recovered N: 389007094093500254659269222829300387668660508842596830283034437854937893235049227182800673983137449438686100431357337665683342739525263623592976332059392395264355698296935420024804741703608973190824917028700611656793563033953362739610335126391232258457097837434427619484534528039920830798211549635295178547023617400379055165909284909149495704721001995786010441636120118520833637102034834824318276159998436988458827216771341547723063116002296802980383058543399672672199299812493420476411710717355307773919162706183079395944012029903656708803248090318792228189733289364091794724586461446778415085835534447274059679497460815715111338701331142301424455494636080084200859380926481450668571474030244841321651468346520918746151217651066760145599691569837763734157601936442708850694948902162338810617437621276232570511323743061902828900722778980874258644691568558368246727586863719198403474239414064157294529929203124574829369966931627809307593655658002862921413850262644887434399341306324601519965584391277327657682339232296466760699235858204994705697120103836006265934580279994007554238442080989089861523384446940617433150587916974122607314408287293310331411631383254795350186812538871979413905851197122211878687803160562136852590752062852078911108328555229
N bit length: 4155
```

- Script to verify that N is correct :
```
# Running modular exponentiation checks for c2 and c3
from Crypto.Util.number import bytes_to_long
# Define values (copied from the conversation)
e = 0x10001

m2_bytes = b"Lorem Ipsum is simply dummy text of"
m3_bytes = b"the printing and typesetting industry"


c2_given = 418890251904422338706957611421569713599475826871001739558191684601388449650152765911998711537988904079604825287425796246874064998467581933676766740276223130512121475534509500906303621372902538391197985667314991617366490958256261589788658330879501311575214355098129174833153268908921830243668239944880771231374562140218364497357200136629700069255932543223923482495870074707111120451362554833143866196241248965622137300308458020075178884826599869468192779089688042987230897822965311025559085617532440006008145374498239750459752867013499291186919435971476183536368572315123025685251906580373379532567407841278998750211643222814641379014359519765178922197378415008018742373687025319912434754473634000405621670429845615829606319472740366005692531091593902806059645864340549295004347573958153532603707014866773610622706191722954455556234964159294477921147142970948281403986676992495675871973003546547451018697326653270306439888029057025155935266124316232802691884200364090521817258795495048568535319874983392804957488408543560193998026023621855563942643595344375058898780939408936693927767141418075631817772771640076304380687135796731638368500728706355472787829783253738799261390172744812173292451298312862797200064214691060544863197664295108731846015154030

c3_given = 190811810050120865209824156809130063824082642875503984673341489763098727366205427052055470133956484888192787556965279057458202735763644682287126187488739754220453671617499360949402433803882789421289935722233410202158060161348469706317857657769596851756905143749344637459844481376063180759972165940828773282680870459825143243399853241097497965072703350090121459446119240686304376184692974401763638611364778015316493372724928332273667590520228859317736827518766547377260996083605920415799146639391124864236867655377010515929434187252987380987561774605013059520927018672304916705706757027248997822223146098187788646663485506011562999914062490090582015271726864412996313153191609573998301503216079446263452984530121506373642374695022390392750139738397412705355004162736773499011351292523952173218848820917869266831297020607745283412199967104923346668987493844788535168652353006869247800301797740066427143271091200731194446853114363751413040812819492693548358259468689679973375925525937014969548066932002942276967982618075738500601962311495855729288949425174472363574117979597855715622935810469813738764225650898950251164414659358486839805968243664080511823670381190757948934415918646156517685118376421251462932816329678098177731334821361792754081126859001

n_candidate = 1314128611846500918795990438026087067954022930391193189555893070625484242614041970962271096939563219463666493107315840816325341171661703421870782414223242117570832424509366068501791432252189685131103253131463946031011221719169771710279423375103044167114410556734037776432559813595089017978537259682730686928704340538777850229279707377216986920783454479033150032534715129892950002711570443940671282653555979897220666550353422198098517731000692073170291375183834162188590521675247206086027379701777689020779044513164620317132441701951693704729917811479626315926728804892870022173000974796509696660890706339655708170882483243048151534795459726867707485152449540305789125642639291867237155836807917298561278606576786798353772411345629855641573136936192268169065178341784959889199041784619107337599763715113745145008591387744454309331343609220323920758334921220681640990222142216454381801977857320713615102999724437259964116569812856439892871616643230984008781375550366312730137130679093387335372910231322894970886417093748232818141505396011195511282860807529232111076710892980289992506540904344775882237386913647212179117166459986685725698492130685846920815204516369312730328433060722863989544437938155013169438351561757506080281234867769438797458586276382
c1 = 448460614418210167098423669378333610872853118969873220291983197117877085788496431866260614635825627856559358989501325551110746888245223368672502689533122765261523731243946020360335223214722737310410239116490480240464763195831296797531281169696073444264552294453348008927081194570876904329242754184288805935254982276331341330183580890462510450605053156174476618987288994077283452641018931274426775483488334245991073609858426623671554514066850654900847503515595374917906619976459063918531715051612988942155763335203472551889888311440392402981057493579351486261460938920694063586809661181757140309845989880469323951795178283256766711324763772988511882471680133152522268943506909448821467207657317715002526569138778600228929439598232153311868911525058320979950196916511254734247408438555799802201785356056032947122753163250079568869004106192780860036427294382962709716383150685604638728461574770754577484332203305849753464113123630234152937796226609332862930004180795410207499938859135016393658462399717357371442661407016080199507616567413277199808069082336534542625939387751949555819295679064653483584415969089450624053537751587839853852413276184794920691323693894997669159086140691413099798542666801838250632768893314293037934977592481961617881910058708

# Convert plaintexts
m2 = bytes_to_long(m2_bytes)
m3 = bytes_to_long(m3_bytes)

# Compute ciphertexts mod n
c2_calc = pow(m2, e, n_candidate)
c3_calc = pow(m3, e, n_candidate)

# c1 = pow(m1,e,n_candidate)
# we know c1 but me dont know m1



print("c2_given == c2_calc ?", c2_given == c2_calc)
print("c3_given == c3_calc ?", c3_given == c3_calc)

# If they don't match, print the computed values for inspection (but they match?)
if c2_given != c2_calc:
    print("Calculated c2:", c2_calc)
else:
    print("c2 matches provided ciphertext.")

if c3_given != c3_calc:
    print("Calculated c3:", c3_calc)
else:
    print("c3 matches provided ciphertext.")

```

- thus we have our N value.
- I tried factorDB like protocol but got nothing thats ok
- gnfs takes 10^48 seconds or years or whatever to factorise this value since bitlength is too high
- this is not a prime number i checked using is_prime()
- Now since we have Nand we know N = p*q and d = (p-1)(q-1)
- lets look at how p and q are generated
- `self.p = next_prime(self.u1*self.base + randint(2, 2**self.lb))`
- next prime of u1 * base + x ( is a random value from 2 - 2^256)
- if u look at the base gen carefully it can only take two values (2^2048)-1 or 2^2048.
- and u can find u1 and u2 by bruteforcing.

```py
from Crypto.Util.number import bytes_to_long, long_to_bytes
from math import isqrt, gcd
import logging


logging.basicConfig(
    level=logging.INFO,
    format="[%(levelname)s] %(message)s"
)
log = logging.getLogger()


c0 = 815188129004593690
c1 = 127925291615994657581931619146695269807090069321028068300026702785628490435087413298680092490257386473119689267569976305630148807575684825719646470673354518537583693756638610236703360575725390523075157347945650329643185755019374721283312409555437073732909098741047201773844526561647418227464551267229483364364787507813737149585117565634566192141414340259600731010898093526776126496041547237731611641645486484003184145020567881814736379969229029494635289881135938616525514478902350456632528118064943796968955206904548914444880294647813769276998813113219946458705248043346165647674144729512746228364422970492090341913955974680328429531371057246002643999064173272750228905488785306922291142352536443928185480992771540164041351189897263855717835200997174303403999921094709386555246470299674355058943232903678863339196093611888915090594863104904225697723818302850752252778621729255567862244645828296741411364052759345927008961382069718216739397512177938134054358858778504307167668875379987274830574712603824004594928740077761311104953146589024383734236839245668317380100215644546947907324757631546712895527026941128733402210258099040798244092233062921213678241433301492159422755411303594795618110694805740300672599304274581599355787281881473140136530753285
c2 = 104454128536114134666041330893412849924539319238173846030358370053912259066553198144201647771409151179389296499444225182922737580937571253329036303241246786394696273703737240494606350619424942154134043974057071462964750990605316877522861478098457922126670980711982715700886739488588258928454751146720846461285104408526738717417461756044249496795236713285815410740335507214955619176318929380672905570604946736070454970829122165657529519191829096299562653289959758115282220314539044233440940890830246113981226775616062418119272940675413756550528704261381830683804964448149613789234326868825958311202712158979318207791357868949882157781068305218079123962336473944242076822566261833638654949217602001305205868861207596016799305223552788863815955231724125485952140180911558328890683991762828843660578236671443539626857037266048369875048432191608492096923173890923193063698396903093080818130375913491435899432596884306387277070900092571026594195475769816837963280460673050909448174467601579491721191905742242149320815840931148597139521486968369237822382185925961430998718690684270284663782612688833325942954176755873192287461806363161966656749124978838440843037636615696962613067946478062682619739085469224316287147692903237078068956379036902948739451784308
c3 = 287293965964521577536949600465877039412983676330501517864975724662075373903418313335625721299388975721491357903306320184247853204477040142941778760057485916689064629860222657837690248122034022696608633347098541733229160810131864253603149064874701423636836348322909135954798560398776651665237804954916116590130313684752444052866519034694526102201271444707642449670451542864865493541141728546221679654661093081848121118684594168895062943920921063566925549212250270641028144352434459819122102852072762780335391277683962786782857084040582699842796641523261150308932398544110620418151887847658837961044285094404774616962577265970393150696357457400719726381090518685568644813512490876890790663593699326420593277088351600861395830498853994952245899881834621106473224692036187989636146643992437367194572335837111809655664187790935259739926115874944166340456171845363032300979740488782920318711668046034568790879401209465850491455677846746238706089490902017942125993304620807882387410264371825909245185927481186838760450566656551893404361562801495420174484277284394683958112760663980049171039021132584343301267863299152953512497843386144751245181609419591873712505993146385725244308823894723973026051800808472848805433371109206822668160634407950261536850484088
e  = 0x10001



base_solutions = []
limit = isqrt(c0) + 1  # |u1| can't be larger than sqrt(c0)



for u1 in range(limit):
    if u1 % 1000000 == 0:
        log.info(f"Checked u1 = {u1:,} / {limit:,} Found {len(base_solutions)} base pairs so far")
    
    rem = c0 - u1*u1
    if rem < 0:
        break  # No need to continue, remainder will only get more negative
    
    u2 = isqrt(rem)
    if u2*u2 == rem:
        base_solutions.append((u1, u2))
        log.info(f"Base solution #{len(base_solutions)}: u1={u1}, u2={u2}")

if not base_solutions:
    log.error(f"No valid (u1,u2) pairs found in range [0, {limit:,}].")
    exit(1)

# Generate all sign combinations

all_solutions = []

for u1, u2 in base_solutions:
    # Generate all combinations: (+u1,+u2), (+u1,-u2), (-u1,+u2), (-u1,-u2)
    sign_combos = [
        (u1, u2),
        (u1, -u2),
        (-u1, u2),
        (-u1, -u2)
    ]
    
    
    for combo in sign_combos:
        if combo not in all_solutions:
            all_solutions.append(combo)


log.info(f"Total solutions found : {len(all_solutions)}")


for idx, (u1, u2) in enumerate(all_solutions, 1):
    log.info(f"Pair {idx}: u1 = {u1:>10}, u2 = {u2:>10}")
    log.info(f"  Check: ({u1})^2 + ({u2})^2 = {u1**2 + u2**2} == {c0}: {u1**2 + u2**2 == c0}")


```

- output - :
```
[INFO] Total solutions found: 8
[INFO] ============================================================
[INFO] Pair 1: u1 = 60616161, u2 = 900840613
[INFO]   Check: 60616161^2 + 900840613^2 = 815188129004593690 == 815188129004593690: True
[INFO] Pair 2: u1 = 96674589, u2 = 897687113
[INFO]   Check: 96674589^2 + 897687113^2 = 815188129004593690 == 815188129004593690: True
[INFO] Pair 3: u1 = 492011439, u2 = 757042187
[INFO]   Check: 492011439^2 + 757042187^2 = 815188129004593690 == 815188129004593690: True
[INFO] Pair 4: u1 = 615951939, u2 = 660144937
[INFO]   Check: 615951939^2 + 660144937^2 = 815188129004593690 == 815188129004593690: True
[INFO] Pair 5: u1 = 660144937, u2 = 615951939
[INFO]   Check: 660144937^2 + 615951939^2 = 815188129004593690 == 815188129004593690: True
[INFO] Pair 6: u1 = 757042187, u2 = 492011439
[INFO]   Check: 757042187^2 + 492011439^2 = 815188129004593690 == 815188129004593690: True
[INFO] Pair 7: u1 = 897687113, u2 = 96674589
[INFO]   Check: 897687113^2 + 96674589^2 = 815188129004593690 == 815188129004593690: True
[INFO] Pair 8: u1 = 900840613, u2 = 60616161
[INFO]   Check: 900840613^2 + 60616161^2 = 815188129004593690 == 815188129004593690: True

```

- Now we have 8 pairs but if we look closely there are only 5 values of u1 and u2.
- no we can guess p.

- `P is basically nextPrime(base*u1 + x)`

- where x is our random [0,2^256] entropy.
- but if u look carefully at base * u1 : base can take two values and u can take 5 values and base * u1 is astronomically bigger than x.

- i ran ascript to verify the above : 
```
C:\Cryptonite\pwn.college_satwik\Cryptography\chal4>python -u "c:\Cryptonite\pwn.college_satwik\Cryptography\chal4\testbits.py"
u1 = 60616161 -> bitlen(u1) = 26
u2 = 900840613 -> bitlen(u2) = 30

p total bits = 2074, known high bits = 1818
q total bits = 2078, known high bits = 1822

Known fraction of p = 87.656702%
Known fraction of q = 87.680462%
```

- therefore we know forsure that almost 87% of the bits of p/q are known to us already and we need to get the last worst case 256 bits.

- doing some research i got to know the coppersmith attack which lets use predict x in `f = p' + x` if `p'` is a majority bit contributor.
  
- thus i took all the combinations of p i had and ran a coppersmith which yielded me the p and q values easily and then cracking the ciphertext is standard rsa decryption.


```python

from sage.all import *
import itertools

N = 389007094093500254659269222829300387668660508842596830283034437854937893235049227182800673983137449438686100431357337665683342739525263623592976332059392395264355698296935420024804741703608973190824917028700611656793563033953362739610335126391232258457097837434427619484534528039920830798211549635295178547023617400379055165909284909149495704721001995786010441636120118520833637102034834824318276159998436988458827216771341547723063116002296802980383058543399672672199299812493420476411710717355307773919162706183079395944012029903656708803248090318792228189733289364091794724586461446778415085835534447274059679497460815715111338701331142301424455494636080084200859380926481450668571474030244841321651468346520918746151217651066760145599691569837763734157601936442708850694948902162338810617437621276232570511323743061902828900722778980874258644691568558368246727586863719198403474239414064157294529929203124574829369966931627809307593655658002862921413850262644887434399341306324601519965584391277327657682339232296466760699235858204994705697120103836006265934580279994007554238442080989089861523384446940617433150587916974122607314408287293310331411631383254795350186812538871979413905851197122211878687803160562136852590752062852078911108328555229
u1_candidates = [60616161, 96674589, 492011439, 615951939, 660144937]
base_candidates = [2**2048 - 1, 2**2048]
X_bound = 2**256  # offset upper bound

print(f"Starting small root search for {len(u1_candidates)} u1s × {len(base_candidates)} bases")


for base in base_candidates:
    for u1 in u1_candidates:
        print(f"\nTrying u1={u1}, base={base >> 2040}...(truncated)")

        P0 = u1 * base
        ZmodN = Zmod(N)
        x = PolynomialRing(ZmodN, 'x').gen()
        f = (P0 + x)

        # Use Coppersmith to find small roots
        roots = f.small_roots(X=X_bound, beta=0.4)
        if roots:
            for r in roots:
                p_candidate = Integer(P0 + r)
                if N % p_candidate == 0:
                    q_candidate = N // p_candidate
                    print(f"Found valid p,q for u1={u1}, base={base}")
                    print(f"p={p_candidate}\nq = {q_candidate}")
                    quit()
        else:
            print("No roots found in range")

print("fail")
```


```bash
(sage) ss@Satwik:~/coppersmith$ sage univariate.sage
[+] Starting small root search for 5 u1s × 2 bases

[*] Trying u1=60616161, base=255...(truncated)
[-] No roots found in range

[*] Trying u1=96674589, base=255...(truncated)
[-] No roots found in range

[*] Trying u1=492011439, base=255...(truncated)
[+] Found valid p,q for u1=492011439, base=32317006071311007300714876688669951960444102669715484032130345427524655138867890893197201411522913463688717960921898019494119559150490921095088152386448283120630877367300996091750197750389652106796057638384067568276792218642619756161838094338476170470581645852036305042887575891541065808607552399123930385521914333389668342420684974786564569494856176035326322058077805659331026192708460314150258592864177116725943603718461857357598351152301645904403697613233287231227125684710820209725157101726931323469678542580656697935045997268352998638215525166389437335543602135433229604645318478604952148193555853611059596230655
    p = 15900336661317465318564232208300058060118974033590457019229973489363475782853135829256950377256219834741960372018328811182551816335678655644429777687507703877261008561318294633235390823703775543774109998188286718941095289798357972959015077680491413700440182742648763524394072929618827716086700442160867328316461837205776468887145957810416351703579690269178218550372302736409801974421180866639460792497218914751202481098366169305124702334471240963494119699607775093336383843968430950257156340121736865514491012602531675516010309647192428019953460929328787281821611122670785136667494506131169958317348307605392021384747242028329
    q = 24465336953517562924106156911826018553319540976333948699447534971518714922749336825863392778858793409162652132362494212868796904698763509029469969840426077416037584221870348368577022362637462333098045037540329657844034602545791031614164636877912318340433948337885042773066739248060723260059184892949877143091263163375961645150820227350460699907099404756240428109513563012500937025882296249627018811757439238401562625397685696770078296823932408099169368172008807906727357922077351794134131601209937565918289872062232970500945605717629979977082702949348270916504726143040039099671798403935770866181583244864425666458341050686101
```

- `NOW WE KNOW OUR P AND Q values and i verified by doing p*q==N and also re-encrypting known plaintexts`

- Then we run this script to get the flag :
```python
import math
from Crypto.Util.number import bytes_to_long

u1 = 60616161
u2 = 900840613
base_bits = 2048
x_bits = 256

bitlen_u1 = u1.bit_length()
bitlen_u2 = u2.bit_length()

p_total_bits = base_bits + bitlen_u1
q_total_bits = base_bits + bitlen_u2

p_known_bits = p_total_bits - x_bits
q_known_bits = q_total_bits - x_bits

print(f"u1 = {u1} -> bitlen(u1) = {bitlen_u1}")
print(f"u2 = {u2} -> bitlen(u2) = {bitlen_u2}")
print()
print(f"p total bits = {p_total_bits}, known high bits = {p_known_bits}")
print(f"q total bits = {q_total_bits}, known high bits = {q_known_bits}")
print()
print(f"Known fraction of p = {p_known_bits / p_total_bits * 100:.6f}%")
print(f"Known fraction of q = {q_known_bits / q_total_bits * 100:.6f}%")

y = u1 * (2**base_bits )
print(f"y = {y} -> bitlen(y) = {y.bit_length()}")


number =..
result = math.log2(number)
print(f"log2(number) = {result} -> bitlen(number) = {math.ceil(result)}")

p=..
q=..
print(p*q==number)

c0 = 815188129004593690
c1 = ..
c2 = ..
c3 = ..

e = 0x10001

m_ = bytes_to_long(b"Lorem Ipsum is simply dummy text of")
c = pow(m_, e, p*q)
print(c==c1)


e = 0x10001
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
print("d =", d)


m = pow(c1, d, p*q)
print(bytes.fromhex(hex(m)[2:]))
```


- OUTPUT

```bash
b'MCTF{hardy_muskat_williams2coppersmith}'
```



