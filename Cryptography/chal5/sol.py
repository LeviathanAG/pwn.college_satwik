from Crypto.Util.number import long_to_bytes
import gmpy2

n = 19839772406592038190388369555693240762538001200560061266337400393390156583067094925964221108025393509323129492181808800544023673275469504815756943291095595848265120220669476825666894482813540241527304775449458006280511430395083776478716286901666159754102681493836770408600291259628536040434644542060008861460420239246675790014643348741981881010487160862738716411889615506716421080697468265585927037843912107880024620419353850828958766380546515595072180248367832537298679740790910760381847091223213725252496813564585753065499199756614019421519942263274322634395687433695110598812240962419691874373000201021934599758797
suspect1 = 5481486211302967857769378509759769524898893113769798571566110518298239375346559533567130904334120310259073521689660742329402669803133955525980601074061060366523204309605656941088516563019896350744848647220202699971933873327122537767517470710991239051145546233486350769062812973389594972516798683040238948422580474396838973908938438667987996165190322222109916886919741191377317838047550364750510197486200306552822564654524636230517193400552655480382550090475112152259065912376331879070271050217631265029575688136893103014397737263756000822849774077743242156386781732974791603691819070298846187429459320822647710620293
suspect2 = 15471195868740783618434039853444325091271961027566455380499276767098755025135594696728733163606916023568535782480341237444034508459734566848020061886214821897207138082654569949589331097642340763425757407284917986100913980642765560090771257023522726807588417681283124019065392862167108175329291155234133431256495186165800850480939395948647023937960370587015180526235807164349620200372082282153041480140456912677691184030985478987260144919138692599055396440254136094165144465177387897117241518119002151156994012940982185071384104913576348164605987962727398059082040045985921247609152298846513278146669552901243070877548
suspect3 = 19399106641059719430021192160300204748154013890459468255719373754354019167820792318092409182406115115530722200666728245446889796562750491115857160508014999883632529321252844540803747198849908691018558610987780941352925318030705567748409124616428965718613582321101358603980688505770743832166552232290945499674026703080355911673609019440196413604866135380765992660957896795208203543126720721831806050402994470347462682914357117859227310008496022278900904627608587245076871675416071315270832931533605319537498860164513939297842228067992324510225950750517047989392427879860701099273608883718222060264811834053566449919927
e = 0x10001

print("Attempting to factor n using leaked information from suspect1...")

# suspect1 = (1234*p + q)^4321 mod n
# We need to find the 4321-th root of suspect1 modulo n

# Use integer arithmetic for nth root
def iroot(n, k):
    """Compute the integer k-th root of n"""
    if n == 0:
        return 0
    if k == 1:
        return n
    
    # Use binary search
    low = 0
    high = n
    
    while low < high:
        mid = (low + high + 1) // 2
        if mid ** k <= n:
            low = mid
        else:
            high = mid - 1
    
    return low

# Try to find k = 1234*p + q by computing approximate 4321-th root
print("Computing approximate 4321-th root...")
k_approx = iroot(suspect1, 4321)

print(f"Testing values around k â‰ˆ {k_approx}")

# Check values around the approximation
found = False
for offset in range(-100000, 100000):
    if offset % 10000 == 0:
        print(f"Testing offset {offset}...")
    
    k = k_approx + offset
    
    # Check if this k works
    if pow(k, 4321, n) == suspect1:
        print(f"\nâœ“ Found k = 1234*p + q = {k}")
        
        # Now solve the system:
        # 1234*p + q = k
        # p * q = n
        # 
        # Substitute q = k - 1234*p into p*q = n:
        # p * (k - 1234*p) = n
        # p*k - 1234*p^2 = n
        # 1234*p^2 - k*p + n = 0
        
        # Quadratic formula: p = (k Â± sqrt(k^2 - 4*1234*n)) / (2*1234)
        a = 1234
        b = -k
        c = n
        
        discriminant = b*b - 4*a*c
        
        if discriminant >= 0:
            # Compute integer square root
            sqrt_disc = gmpy2.iroot(discriminant, 2)[0]
            
            # Check if it's a perfect square
            if sqrt_disc * sqrt_disc == discriminant:
                p1 = (-b + sqrt_disc) // (2*a)
                p2 = (-b - sqrt_disc) // (2*a)
                
                for p in [p1, p2]:
                    if p > 0 and n % p == 0:
                        q = n // p
                        print(f"âœ“ Found p = {p}")
                        print(f"âœ“ Found q = {q}")
                        print(f"âœ“ Verification: p*q = n? {p*q == n}")
                        
                        # Compute private key
                        phi = (p - 1) * (q - 1)
                        d = pow(e, -1, phi)
                        
                        # Decrypt flag
                        flag_int = pow(suspect3, d, n)
                        flag = long_to_bytes(flag_int)
                        
                        try:
                            print(f"\nðŸš© Flag: {flag.decode()}")
                        except:
                            print(f"\nðŸš© Flag (hex): {flag.hex()}")
                        
                        found = True
                        break
            
            if found:
                break
        
        if found:
            break

if not found:
    print("\nâœ— Could not find valid k value in the search range.")
    print("The search range may need to be expanded.")